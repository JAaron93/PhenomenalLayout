"""
Professional Document Translator with Advanced Formatting Preservation
Based on amazon-translate-pdf approach with comprehensive layout preservation
"""

import os
import asyncio
import logging
import tempfile
import uuid
import json
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple, Dict, Any
import mimetypes

import gradio as gr
import uvicorn
from fastapi import FastAPI, HTTPException, UploadFile, File, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles

# Import our enhanced translation modules
from services.translation_service import TranslationService
from services.enhanced_document_processor import EnhancedDocumentProcessor
from services.language_detector import LanguageDetector
from utils.file_handler import FileHandler
from utils.validators import FileValidator
from config.settings import Settings

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Initialize services with enhanced processing
settings = Settings()
translation_service = TranslationService()
document_processor = EnhancedDocumentProcessor(
    dpi=settings.get('PDF_DPI', 300),
    preserve_images=settings.get('PRESERVE_IMAGES', True)
)
language_detector = LanguageDetector()
file_handler = FileHandler()
file_validator = FileValidator()

# FastAPI app
app = FastAPI(
    title="Advanced Document Translator",
    description="Professional document translation with advanced formatting preservation",
    version="2.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Static files and directories
os.makedirs("static", exist_ok=True)
os.makedirs("uploads", exist_ok=True)
os.makedirs("downloads", exist_ok=True)
os.makedirs(".layout_backups", exist_ok=True)
app.mount("/static", StaticFiles(directory="static"), name="static")

# Global state for translation jobs
translation_jobs: Dict[str, Dict[str, Any]] = {}

class AdvancedTranslationState:
    """Enhanced translation state management with comprehensive processing info"""
    
    def __init__(self):
        self.current_file = None
        self.current_content = None
        self.source_language = None
        self.target_language = None
        self.translation_progress = 0
        self.translation_status = "idle"
        self.error_message = ""
        self.job_id = None
        self.output_file = None
        self.processing_info = {}
        self.backup_path = None

# Global state instance
state = AdvancedTranslationState()

async def process_file_upload(file) -> Tuple[str, str, str, str]:
    """Process uploaded file with advanced content extraction"""
    try:
        if file is None:
            return "", "No file uploaded", "", ""\n        \n        # Validate file\n        validation_result = file_validator.validate_file(file.name, len(file.read()) if hasattr(file, 'read') else 0)\n        if not validation_result[\"valid\"]:\n            return "", f\"❌ {validation_result['error']}\", \"\", \"\"\n        \n        # Reset file pointer if it's a file object\n        if hasattr(file, 'seek'):\n            file.seek(0)\n        \n        # Save uploaded file\n        file_path = file_handler.save_uploaded_file(file)\n        state.current_file = file_path\n        \n        logger.info(f\"Starting advanced processing of: {file.name}\")\n        \n        # Extract content with advanced processing\n        content = document_processor.extract_content(file_path)\n        state.current_content = content\n        \n        # Generate preview\n        preview = content.get('preview', 'Preview not available')\n        \n        # Detect language based on content type\n        if content['type'] == 'pdf_advanced':\n            # Use first page text for language detection\n            first_page_texts = content['text_by_page'].get(0, [])\n            sample_text = ' '.join(first_page_texts[:5])  # First 5 text elements\n        else:\n            sample_text = content.get('text_content', '')[:1000]\n        \n        detected_lang = language_detector.detect_language_from_text(sample_text)\n        state.source_language = detected_lang\n        \n        # Store processing info\n        metadata = content.get('metadata')\n        if metadata:\n            state.processing_info = {\n                'file_type': metadata.file_type,\n                'total_pages': metadata.total_pages,\n                'total_elements': metadata.total_text_elements,\n                'file_size_mb': metadata.file_size_mb,\n                'processing_time': metadata.processing_time,\n                'dpi': getattr(metadata, 'dpi', 'N/A')\n            }\n        \n        # Create status message with detailed info\n        status_parts = [\n            f\"✅ File processed successfully\",\n            f\"📄 Type: {Path(file.name).suffix.upper()}\",\n            f\"🌐 Detected language: {detected_lang}\"\n        ]\n        \n        if metadata:\n            status_parts.extend([\n                f\"📊 Pages: {metadata.total_pages}\",\n                f\"📝 Text elements: {metadata.total_text_elements}\",\n                f\"💾 Size: {metadata.file_size_mb:.2f} MB\",\n                f\"⏱️ Processing: {metadata.processing_time:.2f}s\"\n            ])\n            \n            if hasattr(metadata, 'dpi'):\n                status_parts.append(f\"🖼️ Resolution: {metadata.dpi} DPI\")\n        \n        status = \"\\n\".join(status_parts)\n        \n        # Processing details for display\n        processing_details = json.dumps(state.processing_info, indent=2)\n        \n        logger.info(f\"Advanced processing complete: {file.name}\")\n        return preview, status, detected_lang, processing_details\n        \n    except Exception as e:\n        logger.error(f\"File upload error: {str(e)}\")\n        return \"\", f\"❌ Upload failed: {str(e)}\", \"\", \"\"\n\nasync def start_translation(target_language: str) -> Tuple[str, str, bool]:\n    \"\"\"Start the advanced translation process\"\"\"\n    try:\n        if not state.current_file or not state.current_content:\n            return \"❌ No file processed\", \"\", False\n        \n        if not target_language:\n            return \"❌ Please select target language\", \"\", False\n        \n        state.target_language = target_language\n        state.job_id = str(uuid.uuid4())\n        state.translation_status = \"starting\"\n        state.translation_progress = 0\n        state.error_message = \"\"\n        \n        # Start translation in background\n        asyncio.create_task(perform_advanced_translation())\n        \n        return \"🚀 Advanced translation started...\", \"Translation in progress with format preservation\", False\n        \n    except Exception as e:\n        logger.error(f\"Translation start error: {str(e)}\")\n        return f\"❌ Failed to start translation: {str(e)}\", \"\", False\n\nasync def perform_advanced_translation():\n    \"\"\"Perform the advanced translation process with format preservation\"\"\"\n    try:\n        state.translation_status = \"processing\"\n        logger.info(f\"Starting advanced translation: {state.source_language} -> {state.target_language}\")\n        \n        content = state.current_content\n        \n        # Extract text for translation based on content type\n        state.translation_progress = 10\n        if content['type'] == 'pdf_advanced':\n            text_by_page = content['text_by_page']\n        elif content['type'] in ['docx', 'txt']:\n            # Convert to page-based format for consistency\n            if content['type'] == 'docx':\n                texts = [para['text'] for para in content['paragraphs'] if para['text'].strip()]\n            else:\n                texts = content['lines']\n            text_by_page = {0: texts}\n        else:\n            raise ValueError(f\"Unsupported content type: {content['type']}\")\n        \n        # Translate content page by page\n        state.translation_progress = 30\n        translated_by_page = {}\n        \n        total_pages = len(text_by_page)\n        for page_num, page_texts in text_by_page.items():\n            if not page_texts:\n                translated_by_page[page_num] = []\n                continue\n            \n            logger.info(f\"Translating page {page_num + 1}/{total_pages} ({len(page_texts)} elements)\")\n            \n            # Translate each text element\n            translated_texts = []\n            for i, text in enumerate(page_texts):\n                if text.strip():\n                    try:\n                        translated_text = await translation_service.translate_text(\n                            text,\n                            state.source_language,\n                            state.target_language\n                        )\n                        translated_texts.append(translated_text)\n                    except Exception as e:\n                        logger.warning(f\"Translation failed for text element {i}: {e}\")\n                        translated_texts.append(text)  # Keep original if translation fails\n                else:\n                    translated_texts.append(text)\n            \n            translated_by_page[page_num] = translated_texts\n            \n            # Update progress\n            page_progress = 30 + (page_num + 1) / total_pages * 50\n            state.translation_progress = int(page_progress)\n        \n        # Generate output file with preserved formatting\n        state.translation_progress = 85\n        output_filename = generate_output_filename(\n            Path(state.current_file).name,\n            state.target_language\n        )\n        \n        logger.info(f\"Creating translated document: {output_filename}\")\n        state.output_file = document_processor.create_translated_document(\n            content,\n            translated_by_page,\n            output_filename\n        )\n        \n        state.translation_progress = 100\n        state.translation_status = \"completed\"\n        \n        logger.info(f\"Advanced translation completed: {state.output_file}\")\n        \n    except Exception as e:\n        logger.error(f\"Advanced translation error: {str(e)}\")\n        state.translation_status = \"error\"\n        state.error_message = str(e)\n\ndef update_translation_progress(progress: int):\n    \"\"\"Update translation progress\"\"\"\n    state.translation_progress = min(30 + (progress * 0.6), 90)\n\ndef generate_output_filename(original_filename: str, target_language: str) -> str:\n    \"\"\"Generate output filename with proper format\"\"\"\n    name = Path(original_filename).stem\n    ext = Path(original_filename).suffix\n    return f\"translated_{name}_{target_language.lower()}_advanced{ext}\"\n\ndef get_translation_status() -> Tuple[str, int, bool]:\n    \"\"\"Get current translation status with detailed info\"\"\"\n    if state.translation_status == \"idle\":\n        return \"Ready for advanced translation\", 0, False\n    elif state.translation_status == \"starting\":\n        return \"🚀 Initializing advanced translation...\", 5, False\n    elif state.translation_status == \"processing\":\n        return f\"🔄 Advanced translation in progress... ({state.translation_progress}%)\", state.translation_progress, False\n    elif state.translation_status == \"completed\":\n        return \"✅ Advanced translation completed with format preservation!\", 100, True\n    elif state.translation_status == \"error\":\n        return f\"❌ Translation failed: {state.error_message}\", 0, False\n    else:\n        return \"Unknown status\", 0, False\n\ndef download_translated_file(output_format: str) -> str:\n    \"\"\"Prepare file for download with format conversion if needed\"\"\"\n    try:\n        if not state.output_file or state.translation_status != \"completed\":\n            return \"❌ No translated file available\"\n        \n        # Convert to requested format if needed\n        if output_format != Path(state.output_file).suffix[1:].upper():\n            converted_file = document_processor.convert_format(\n                state.output_file,\n                output_format.lower()\n            )\n            return converted_file\n        \n        return state.output_file\n        \n    except Exception as e:\n        logger.error(f\"Download preparation error: {str(e)}\")\n        return f\"❌ Download failed: {str(e)}\"\n\n# Gradio Interface with Enhanced Features\ndef create_gradio_interface():\n    \"\"\"Create the advanced Gradio web interface\"\"\"\n    \n    with gr.Blocks(\n        title=\"Advanced Document Translator\",\n        theme=gr.themes.Soft(),\n        css=\"\"\"            .gradio-container {\n                max-width: 1400px !important;\n                margin: auto !important;\n            }\n            .upload-area {\n                border: 2px dashed #007bff;\n                border-radius: 10px;\n                padding: 20px;\n                text-align: center;\n                background-color: #f8f9fa;\n            }\n            .status-success {\n                color: #28a745;\n                font-weight: bold;\n            }\n            .status-error {\n                color: #dc3545;\n                font-weight: bold;\n            }\n            .progress-bar {\n                background: linear-gradient(90deg, #007bff, #28a745);\n            }\n            .info-panel {\n                background-color: #e9ecef;\n                border-radius: 8px;\n                padding: 15px;\n                font-family: monospace;\n                font-size: 12px;\n            }\n            \"\"\"\n    ) as interface:\n        \n        gr.Markdown(\n            \"\"\"\n            # 📄 Advanced Document Translator\n            \n            Professional document translation with **comprehensive formatting preservation**.\n            \n            🎯 **Features:**\n            - Advanced PDF processing with image-text overlay technique\n            - Precise text positioning preservation\n            - High-resolution rendering (300 DPI)\n            - Support for complex layouts and embedded images\n            - DOCX and TXT format support\n            - Automatic language detection\n            \n            📊 **Supported Files:** PDF, DOCX, TXT (up to 10MB)\n            \"\"\"\n        )\n        \n        with gr.Row():\n            with gr.Column(scale=1):\n                # File Upload Section\n                gr.Markdown(\"## 📤 Upload Document\")\n                \n                file_upload = gr.File(\n                    label=\"Choose File (PDF, DOCX, TXT)\",\n                    file_types=[\".pdf\", \".docx\", \".txt\"],\n                    file_count=\"single\",\n                    elem_classes=[\"upload-area\"]\n                )\n                \n                upload_status = gr.Textbox(\n                    label=\"Processing Status\",\n                    interactive=False,\n                    lines=8,\n                    max_lines=10\n                )\n                \n                # Advanced Processing Info\n                gr.Markdown(\"## 🔍 Processing Details\")\n                processing_info = gr.Textbox(\n                    label=\"Processing Information\",\n                    interactive=False,\n                    lines=8,\n                    elem_classes=[\"info-panel\"]\n                )\n                \n            with gr.Column(scale=2):\n                # Preview Section\n                gr.Markdown(\"## 👀 Document Preview\")\n                \n                document_preview = gr.Textbox(\n                    label=\"Content Preview\",\n                    lines=12,\n                    interactive=False,\n                    placeholder=\"Upload a document to see preview with advanced processing info...\"\n                )\n                \n                # Language and Translation Section  \n                with gr.Row():\n                    with gr.Column():\n                        detected_language = gr.Textbox(\n                            label=\"Detected Source Language\",\n                            interactive=False\n                        )\n                    \n                    with gr.Column():\n                        target_language = gr.Dropdown(\n                            label=\"Target Language\",\n                            choices=[\n                                \"English\", \"Spanish\", \"French\", \"German\", \"Italian\",\n                                \"Portuguese\", \"Russian\", \"Chinese\", \"Japanese\", \"Korean\",\n                                \"Arabic\", \"Hindi\", \"Dutch\", \"Swedish\", \"Norwegian\",\n                                \"Danish\", \"Finnish\", \"Polish\", \"Czech\", \"Hungarian\"\n                            ],\n                            value=\"English\"\n                        )\n                \n                # Translation Controls\n                translate_btn = gr.Button(\n                    \"🚀 Start Advanced Translation\",\n                    variant=\"primary\",\n                    size=\"lg\"\n                )\n                \n                # Progress Section\n                gr.Markdown(\"## 📊 Translation Progress\")\n                \n                progress_status = gr.Textbox(\n                    label=\"Status\",\n                    interactive=False\n                )\n                \n                progress_bar = gr.Progress()\n                \n                # Export Section\n                gr.Markdown(\"## 💾 Download Translated Document\")\n                \n                with gr.Row():\n                    output_format = gr.Dropdown(\n                        label=\"Output Format\",\n                        choices=[\"PDF\", \"DOCX\", \"TXT\"],\n                        value=\"PDF\"\n                    )\n                    \n                    download_btn = gr.Button(\n                        \"📥 Download\",\n                        variant=\"secondary\",\n                        interactive=False\n                    )\n                \n                download_file = gr.File(\n                    label=\"Download File\",\n                    visible=False\n                )\n        \n        # Event Handlers\n        file_upload.change(\n            fn=process_file_upload,\n            inputs=[file_upload],\n            outputs=[document_preview, upload_status, detected_language, processing_info]\n        )\n        \n        translate_btn.click(\n            fn=start_translation,\n            inputs=[target_language],\n            outputs=[progress_status, upload_status, download_btn]\n        )\n        \n        # Periodic status updates\n        def update_status():\n            status, progress, download_ready = get_translation_status()\n            return status, gr.update(interactive=download_ready)\n        \n        interface.load(\n            fn=update_status,\n            outputs=[progress_status, download_btn],\n            every=2\n        )\n        \n        download_btn.click(\n            fn=download_translated_file,\n            inputs=[output_format],\n            outputs=[download_file]\n        )\n    \n    return interface\n\n# FastAPI Routes (Enhanced)\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint\"\"\"\n    return {\n        \"message\": \"Advanced Document Translator API\", \n        \"version\": \"2.0.0\",\n        \"features\": [\n            \"Advanced PDF processing\",\n            \"Image-text overlay preservation\",\n            \"High-resolution rendering\",\n            \"Comprehensive format support\"\n        ]\n    }\n\n@app.post(\"/upload\")\nasync def upload_file(file: UploadFile = File(...)):\n    \"\"\"Enhanced upload endpoint with advanced processing\"\"\"\n    try:\n        # Validate file\n        validation_result = file_validator.validate_upload_file(file)\n        if not validation_result[\"valid\"]:\n            raise HTTPException(status_code=400, detail=validation_result[\"error\"])\n        \n        # Save file\n        file_path = file_handler.save_upload_file(file)\n        \n        # Process with advanced extraction\n        content = document_processor.extract_content(file_path)\n        \n        # Detect language\n        if content['type'] == 'pdf_advanced':\n            first_page_texts = content['text_by_page'].get(0, [])\n            sample_text = ' '.join(first_page_texts[:5])\n        else:\n            sample_text = content.get('text_content', '')[:1000]\n            \n        detected_lang = language_detector.detect_language_from_text(sample_text)\n        \n        return {\n            \"message\": \"File processed with advanced extraction\",\n            \"filename\": file.filename,\n            \"detected_language\": detected_lang,\n            \"file_path\": file_path,\n            \"content_type\": content['type'],\n            \"metadata\": content.get('metadata').__dict__ if content.get('metadata') else None\n        }\n        \n    except Exception as e:\n        logger.error(f\"Enhanced upload error: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/translate\")\nasync def translate_document(\n    background_tasks: BackgroundTasks,\n    file_path: str,\n    source_language: str,\n    target_language: str\n):\n    \"\"\"Enhanced translation endpoint\"\"\"\n    try:\n        job_id = str(uuid.uuid4())\n        \n        # Create job entry with enhanced info\n        translation_jobs[job_id] = {\n            \"status\": \"started\",\n            \"progress\": 0,\n            \"file_path\": file_path,\n            \"source_language\": source_language,\n            \"target_language\": target_language,\n            \"created_at\": datetime.now(),\n            \"output_file\": None,\n            \"error\": None,\n            \"processing_type\": \"advanced\",\n            \"format_preservation\": True\n        }\n        \n        # Start background translation with advanced processing\n        background_tasks.add_task(\n            process_advanced_translation_job,\n            job_id,\n            file_path,\n            source_language,\n            target_language\n        )\n        \n        return {\"job_id\": job_id, \"status\": \"started\", \"type\": \"advanced\"}\n        \n    except Exception as e:\n        logger.error(f\"Enhanced translation start error: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/status/{job_id}\")\nasync def get_job_status(job_id: str):\n    \"\"\"Get enhanced job status\"\"\"\n    if job_id not in translation_jobs:\n        raise HTTPException(status_code=404, detail=\"Job not found\")\n    \n    return translation_jobs[job_id]\n\n@app.get(\"/download/{job_id}\")\nasync def download_result(job_id: str):\n    \"\"\"Download translated file with enhanced metadata\"\"\"\n    if job_id not in translation_jobs:\n        raise HTTPException(status_code=404, detail=\"Job not found\")\n    \n    job = translation_jobs[job_id]\n    if job[\"status\"] != \"completed\" or not job[\"output_file\"]:\n        raise HTTPException(status_code=400, detail=\"Translation not completed\")\n    \n    return FileResponse(\n        job[\"output_file\"],\n        media_type=\"application/octet-stream\",\n        filename=Path(job[\"output_file\"]).name,\n        headers={\"X-Processing-Type\": \"advanced\", \"X-Format-Preserved\": \"true\"}\n    )\n\nasync def process_advanced_translation_job(job_id: str, file_path: str, source_lang: str, target_lang: str):\n    \"\"\"Process translation job with advanced formatting preservation\"\"\"\n    try:\n        job = translation_jobs[job_id]\n        job[\"status\"] = \"processing\"\n        \n        # Extract content with advanced processing\n        job[\"progress\"] = 20\n        content = document_processor.extract_content(file_path)\n        \n        # Extract text for translation\n        job[\"progress\"] = 40\n        if content['type'] == 'pdf_advanced':\n            text_by_page = content['text_by_page']\n        elif content['type'] in ['docx', 'txt']:\n            if content['type'] == 'docx':\n                texts = [para['text'] for para in content['paragraphs'] if para['text'].strip()]\n            else:\n                texts = content['lines']\n            text_by_page = {0: texts}\n        \n        # Translate with progress tracking\n        job[\"progress\"] = 60\n        translated_by_page = {}\n        for page_num, page_texts in text_by_page.items():\n            translated_texts = []\n            for text in page_texts:\n                if text.strip():\n                    translated_text = await translation_service.translate_text(\n                        text, source_lang, target_lang\n                    )\n                    translated_texts.append(translated_text)\n                else:\n                    translated_texts.append(text)\n            translated_by_page[page_num] = translated_texts\n        \n        # Create output with preserved formatting\n        job[\"progress\"] = 80\n        output_filename = generate_output_filename(\n            Path(file_path).name, target_lang\n        )\n        \n        output_file = document_processor.create_translated_document(\n            content, translated_by_page, output_filename\n        )\n        \n        job[\"progress\"] = 100\n        job[\"status\"] = \"completed\"\n        job[\"output_file\"] = output_file\n        \n        logger.info(f\"Advanced translation job completed: {job_id}\")\n        \n    except Exception as e:\n        logger.error(f\"Advanced translation job error: {str(e)}\")\n        translation_jobs[job_id][\"status\"] = \"error\"\n        translation_jobs[job_id][\"error\"] = str(e)\n\ndef main():\n    \"\"\"Main application entry point\"\"\"\n    logger.info(\"Starting Advanced Document Translator\")\n    \n    # Create Gradio interface\n    gradio_app = create_gradio_interface()\n    \n    # Mount Gradio app to FastAPI\n    app = gr.mount_gradio_app(app, gradio_app, path=\"/\")\n    \n    # Start server\n    uvicorn.run(\n        app,\n        host=\"0.0.0.0\",\n        port=8000,\n        log_level=\"info\"\n    )\n\nif __name__ == \"__main__\":\n    main()"